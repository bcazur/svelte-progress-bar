(function () {
	'use strict';

	function noop() {}

	function assign(tar, src) {
		for (var k in src) tar[k] = src[k];
		return tar;
	}

	function append(target, node) {
		target.appendChild(node);
	}

	function insert(target, node, anchor) {
		target.insertBefore(node, anchor);
	}

	function detachNode(node) {
		node.parentNode.removeChild(node);
	}

	function createElement(name) {
		return document.createElement(name);
	}

	function createText(data) {
		return document.createTextNode(data);
	}

	function createComment() {
		return document.createComment('');
	}

	function addListener(node, event, handler, options) {
		node.addEventListener(event, handler, options);
	}

	function removeListener(node, event, handler, options) {
		node.removeEventListener(event, handler, options);
	}

	function setAttribute(node, attribute, value) {
		if (value == null) node.removeAttribute(attribute);
		else node.setAttribute(attribute, value);
	}

	function toNumber(value) {
		return value === '' ? undefined : +value;
	}

	function blankObject() {
		return Object.create(null);
	}

	function destroy(detach) {
		this.destroy = noop;
		this.fire('destroy');
		this.set = noop;

		this._fragment.d(detach !== false);
		this._fragment = null;
		this._state = {};
	}

	function _differs(a, b) {
		return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
	}

	function fire(eventName, data) {
		var handlers =
			eventName in this._handlers && this._handlers[eventName].slice();
		if (!handlers) return;

		for (var i = 0; i < handlers.length; i += 1) {
			var handler = handlers[i];

			if (!handler.__calling) {
				try {
					handler.__calling = true;
					handler.call(this, data);
				} finally {
					handler.__calling = false;
				}
			}
		}
	}

	function flush(component) {
		component._lock = true;
		callAll(component._beforecreate);
		callAll(component._oncreate);
		callAll(component._aftercreate);
		component._lock = false;
	}

	function get() {
		return this._state;
	}

	function init(component, options) {
		component._handlers = blankObject();
		component._slots = blankObject();
		component._bind = options._bind;
		component._staged = {};

		component.options = options;
		component.root = options.root || component;
		component.store = options.store || component.root.store;

		if (!options.root) {
			component._beforecreate = [];
			component._oncreate = [];
			component._aftercreate = [];
		}
	}

	function on(eventName, handler) {
		var handlers = this._handlers[eventName] || (this._handlers[eventName] = []);
		handlers.push(handler);

		return {
			cancel: function() {
				var index = handlers.indexOf(handler);
				if (~index) handlers.splice(index, 1);
			}
		};
	}

	function set(newState) {
		this._set(assign({}, newState));
		if (this.root._lock) return;
		flush(this.root);
	}

	function _set(newState) {
		var oldState = this._state,
			changed = {},
			dirty = false;

		newState = assign(this._staged, newState);
		this._staged = {};

		for (var key in newState) {
			if (this._differs(newState[key], oldState[key])) changed[key] = dirty = true;
		}
		if (!dirty) return;

		this._state = assign(assign({}, oldState), newState);
		this._recompute(changed, this._state);
		if (this._bind) this._bind(changed, this._state);

		if (this._fragment) {
			this.fire("state", { changed: changed, current: this._state, previous: oldState });
			this._fragment.p(changed, this._state);
			this.fire("update", { changed: changed, current: this._state, previous: oldState });
		}
	}

	function _stage(newState) {
		assign(this._staged, newState);
	}

	function callAll(fns) {
		while (fns && fns.length) fns.shift()();
	}

	function _mount(target, anchor) {
		this._fragment[this._fragment.i ? 'i' : 'm'](target, anchor || null);
	}

	var proto = {
		destroy,
		get,
		fire,
		on,
		set,
		_recompute: noop,
		_set,
		_stage,
		_mount,
		_differs
	};

	/* docs/Controls.html generated by Svelte v2.15.3 */

	function data() {
		return {
			width: 10
		}
	}
	var methods = {
		progressStart() {
			this.get().bar.start();
		},
		progressComplete() {
			this.get().bar.complete();
		},
		progressStop() {
			this.get().bar.stop();
		},
		progressIncrement(size) {
			const bar = this.get().bar;
			const max = bar.get().maximum;
			let width = bar.get().width + size;
			if (width > max) {
				width = max;
			}
			bar.set({ width });
		},
		progressContinue() {
			this.get().bar.continue();
		},
		setWidthRatio(width) {
			this.get().bar.setWidthRatio(width / 100);
		}
	};

	function create_main_fragment(component, ctx) {
		var button0, text1, button1, text3, button2, text5, button3, text7, button4, text9, button5, text11, input, input_updating = false;

		function click_handler(event) {
			component.progressStart();
		}

		function click_handler_1(event) {
			component.progressComplete();
		}

		function click_handler_2(event) {
			component.progressStop();
		}

		function click_handler_3(event) {
			component.progressIncrement(0.2);
		}

		function click_handler_4(event) {
			component.progressContinue();
		}

		function click_handler_5(event) {
			component.setWidthRatio(ctx.width);
		}

		function input_input_handler() {
			input_updating = true;
			component.set({ width: toNumber(input.value) });
			input_updating = false;
		}

		return {
			c() {
				button0 = createElement("button");
				button0.textContent = "Restart";
				text1 = createText("\n");
				button1 = createElement("button");
				button1.textContent = "Complete";
				text3 = createText("\n");
				button2 = createElement("button");
				button2.textContent = "Stop Auto-Increment";
				text5 = createText("\n");
				button3 = createElement("button");
				button3.textContent = "Increment by 20%";
				text7 = createText("\n");
				button4 = createElement("button");
				button4.textContent = "Continue Auto-Increment";
				text9 = createText("\n");
				button5 = createElement("button");
				button5.textContent = "Set Width";
				text11 = createText("\n");
				input = createElement("input");
				addListener(button0, "click", click_handler);
				addListener(button1, "click", click_handler_1);
				addListener(button2, "click", click_handler_2);
				addListener(button3, "click", click_handler_3);
				addListener(button4, "click", click_handler_4);
				addListener(button5, "click", click_handler_5);
				button5.className = "inline";
				addListener(input, "input", input_input_handler);
				input.className = "inline";
				setAttribute(input, "type", "number");
			},

			m(target, anchor) {
				insert(target, button0, anchor);
				insert(target, text1, anchor);
				insert(target, button1, anchor);
				insert(target, text3, anchor);
				insert(target, button2, anchor);
				insert(target, text5, anchor);
				insert(target, button3, anchor);
				insert(target, text7, anchor);
				insert(target, button4, anchor);
				insert(target, text9, anchor);
				insert(target, button5, anchor);
				insert(target, text11, anchor);
				insert(target, input, anchor);

				input.value = ctx.width;
			},

			p(changed, _ctx) {
				ctx = _ctx;
				if (!input_updating && changed.width) input.value = ctx.width;
			},

			d(detach) {
				if (detach) {
					detachNode(button0);
				}

				removeListener(button0, "click", click_handler);
				if (detach) {
					detachNode(text1);
					detachNode(button1);
				}

				removeListener(button1, "click", click_handler_1);
				if (detach) {
					detachNode(text3);
					detachNode(button2);
				}

				removeListener(button2, "click", click_handler_2);
				if (detach) {
					detachNode(text5);
					detachNode(button3);
				}

				removeListener(button3, "click", click_handler_3);
				if (detach) {
					detachNode(text7);
					detachNode(button4);
				}

				removeListener(button4, "click", click_handler_4);
				if (detach) {
					detachNode(text9);
					detachNode(button5);
				}

				removeListener(button5, "click", click_handler_5);
				if (detach) {
					detachNode(text11);
					detachNode(input);
				}

				removeListener(input, "input", input_input_handler);
			}
		};
	}

	function Controls(options) {
		init(this, options);
		this._state = assign(data(), options.data);
		this._intro = true;

		this._fragment = create_main_fragment(this, this._state);

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(Controls.prototype, proto);
	assign(Controls.prototype, methods);

	/* ProgressBar.html generated by Svelte v2.15.3 */

	const getIncrement = number => {
		if (number >= 0 && number < 0.2) return 0.1
		else if (number >= 0.2 && number < 0.5) return 0.04
		else if (number >= 0.5 && number < 0.8) return 0.02
		else if (number >= 0.8 && number < 0.99) return 0.005
		return 0
	};

	let updater;

	function barClass({ completed }) {
		return completed ? 'svelte-progress-bar-hiding' : ''
	}
	function barStyle({ width, color }) {
		const barColorStyle = color && `background-color: ${color};` || '';
		const barWidth = width && width * 100 && `width: ${width * 100}%;` || '';
		return [ barColorStyle, barWidth ].filter(Boolean).join('')
	}
	function leaderColorStyle({ color }) {
		// the box shadow of the leader bar uses `color` to set its shadow color
		return color && `background-color: ${color}; color: ${color};` || ''
	}
	function data$1() {
		return {
			minimum: 0.08,
			maximum: 0.994,
			settleTime: 700,
			intervalTime: 700,
			stepSizes: [ 0, 0.005, 0.01, 0.02 ]
		}
	}
	var methods$1 = {
		start() {
			this.reset();
			this.continue();
		},
		reset() {
			const startingWidth = this.get().minimum;
			this.set({
				width: startingWidth,
				running: true
			});
		},
		continue() {
			const maximumWidth = this.get().maximum;
			const intervalTime = this.get().intervalTime;

			if (updater) {
				// prevent multiple intervals by clearing before making
				clearInterval(updater);
			}
			this.set({ running: true });
			updater = setInterval(() => {
				let value = this.get().width;

				const stepSizes = this.get().stepSizes;
				const randomStep = stepSizes[Math.floor(Math.random() * stepSizes.length)];
				const step = getIncrement(value) + randomStep;
				if (value < maximumWidth) {
					value = value + step;
				}
				if (value > maximumWidth) {
					value = maximumWidth;
					this.stop();
				}
				this.set({ width: value });
			}, intervalTime);
		},
		stop() {
			if (updater) {
				clearInterval(updater);
			}
		},
		complete() {
			clearInterval(updater);
			this.set({
				width: 1,
				running: false
			});
			const settleTime = this.get().settleTime;
			setTimeout(() => {
				this.set({
					completed: true
				});
				setTimeout(() => {
					this.set({
						completed: false,
						width: 0
					});
				}, settleTime);
			}, settleTime);
		},
		setWidthRatio(widthRatio) {
			this.stop();
			this.set({
				width: widthRatio,
				completed: false,
				running: true
			});
		}
	};

	function add_css() {
		var style = createElement("style");
		style.id = 'svelte-1fsw3ov-style';
		style.textContent = ".svelte-progress-bar.svelte-1fsw3ov{position:fixed;top:0;left:0;height:2px;transition:width 0.16s ease-in-out;z-index:1}.svelte-progress-bar-hiding.svelte-1fsw3ov{transition:top 0.16s ease;top:-8px}.svelte-progress-bar-leader.svelte-1fsw3ov{position:absolute;top:0;right:0;height:2px;width:100px;transform:rotate(2.5deg) translate(0px, -4px);box-shadow:0 0 8px;z-index:2}";
		append(document.head, style);
	}

	function create_main_fragment$1(component, ctx) {
		var if_block_anchor;

		var if_block = (ctx.width) && create_if_block(component, ctx);

		return {
			c() {
				if (if_block) if_block.c();
				if_block_anchor = createComment();
			},

			m(target, anchor) {
				if (if_block) if_block.m(target, anchor);
				insert(target, if_block_anchor, anchor);
			},

			p(changed, ctx) {
				if (ctx.width) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block(component, ctx);
						if_block.c();
						if_block.m(if_block_anchor.parentNode, if_block_anchor);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}
			},

			d(detach) {
				if (if_block) if_block.d(detach);
				if (detach) {
					detachNode(if_block_anchor);
				}
			}
		};
	}

	// (1:0) {#if width}
	function create_if_block(component, ctx) {
		var div, div_class_value;

		var if_block = (ctx.running) && create_if_block_1(component, ctx);

		return {
			c() {
				div = createElement("div");
				if (if_block) if_block.c();
				div.className = div_class_value = "svelte-progress-bar " + ctx.barClass + " svelte-1fsw3ov";
				div.style.cssText = ctx.barStyle;
			},

			m(target, anchor) {
				insert(target, div, anchor);
				if (if_block) if_block.m(div, null);
			},

			p(changed, ctx) {
				if (ctx.running) {
					if (if_block) {
						if_block.p(changed, ctx);
					} else {
						if_block = create_if_block_1(component, ctx);
						if_block.c();
						if_block.m(div, null);
					}
				} else if (if_block) {
					if_block.d(1);
					if_block = null;
				}

				if ((changed.barClass) && div_class_value !== (div_class_value = "svelte-progress-bar " + ctx.barClass + " svelte-1fsw3ov")) {
					div.className = div_class_value;
				}

				if (changed.barStyle) {
					div.style.cssText = ctx.barStyle;
				}
			},

			d(detach) {
				if (detach) {
					detachNode(div);
				}

				if (if_block) if_block.d();
			}
		};
	}

	// (3:1) {#if running}
	function create_if_block_1(component, ctx) {
		var div;

		return {
			c() {
				div = createElement("div");
				div.className = "svelte-progress-bar-leader svelte-1fsw3ov";
				div.style.cssText = ctx.leaderColorStyle;
			},

			m(target, anchor) {
				insert(target, div, anchor);
			},

			p(changed, ctx) {
				if (changed.leaderColorStyle) {
					div.style.cssText = ctx.leaderColorStyle;
				}
			},

			d(detach) {
				if (detach) {
					detachNode(div);
				}
			}
		};
	}

	function ProgressBar(options) {
		init(this, options);
		this._state = assign(data$1(), options.data);

		this._recompute({ completed: 1, width: 1, color: 1 }, this._state);
		this._intro = true;

		if (!document.getElementById("svelte-1fsw3ov-style")) add_css();

		this._fragment = create_main_fragment$1(this, this._state);

		if (options.target) {
			this._fragment.c();
			this._mount(options.target, options.anchor);
		}
	}

	assign(ProgressBar.prototype, proto);
	assign(ProgressBar.prototype, methods$1);

	ProgressBar.prototype._recompute = function _recompute(changed, state) {
		if (changed.completed) {
			if (this._differs(state.barClass, (state.barClass = barClass(state)))) changed.barClass = true;
		}

		if (changed.width || changed.color) {
			if (this._differs(state.barStyle, (state.barStyle = barStyle(state)))) changed.barStyle = true;
		}

		if (changed.color) {
			if (this._differs(state.leaderColorStyle, (state.leaderColorStyle = leaderColorStyle(state)))) changed.leaderColorStyle = true;
		}
	};

	const bar = new ProgressBar({
		target: document.querySelector('body'),
		data: {
			// you can either specify the color as a property here, or using CSS
			color: 'blue'
		}
	});

	// wire up the control buttons

	new Controls({
		target: document.querySelector('#controls'),
		data: { bar }
	});

	bar.start();

	setTimeout(() => {
		bar.complete();
	}, 1600);

}());
